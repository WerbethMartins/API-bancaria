Projeto API Bancária
- Usamos o Spring init para gerar o arquivo Spring boot
    // Configurações //
    - Project: Maven
    - Spring Boot: 3.5.4
    - Java: 23
    // Dependências //
    - Spring Web
    - Spring Data JPA
    - Lombok
    - H2 Database (Inicial)
    - Validation

1. Configuração Inicial e Ferramentas
    - Projeto estruturado com camadas: Controller, Service, Model, DTO, Exception e Repository
    - Adicionado conexão com banco de dados
    - Health Controller para testar se a API está funcionalidade.

2. Modelagem das Entidades
    - Criamos a entidade cliente
        - Cliente coma atributos: id, nome, cpf, email
        - Conta Bancaria com: id, numero, saldo, tipo de conta (Corrente, Poupança)
    - Definido relação entre cliente e conta (@OneToMany, ManyToOne)

3. DTOs para entrada e saída de dados
    - Criamos:
        - ClienteDTO para receber dados do cliente na requisição (com validações como @NotBlank, @Size, @Email).
        - ClienteResponseDTO para enviar a resposta com dados do cliente, evitando expor a entidade completa.

4. Lógica de Negócio no Service
    - Criamos o ClienteService com métodos:
        - criarCliente(ClienteDTO dto) que converte DTO em entidade, salva no banco e retorna ClienteResponseDTO.
        - abrirContaCliente(Long clienteId, String tipoConta) que cria uma conta para o cliente, gera número automático, e salva.
        - consultarSaldo(String numeroConta) que retorna o saldo da conta informada.
        - listarClientes() para retornar todos os clientes.

5. Endpoints REST no Controller
    - POST /clientes → cria um cliente usando DTOs.
    - POST /clientes/abrir-conta/{clienteId} → abre uma conta para cliente existente.
    - GET /clientes/saldo/{numeroConta} → consulta saldo da conta.
    - GET /clientes → lista todos os clientes.

6. Validação e tratamento de dados
    - Usamos validação com jakarta.validation nas classes DTO.
    - Número da conta é gerado automaticamente no backend, garantindo unicidade e formato padrão.

7. Criação de testes automatizados com JUnit e Mockito da API
    - teste unitários para clienteService
    - Aprendido a importância de teste em APIs críticas(como sistemas bancários)
        - Garantir que os métodos funcionem corretamente
        - Evitar inconsistência de dados, como saldo errado e cliente inexistente.
        - Cobrir fluxos felizes quanto exceções
    - Testes implementados:
        - Criar clientes
            - Verificar se o cliente é criado corretamente via DTO(ClienteResponseDTO)
            - Confirmar se o repositório foi chamado(save)
        - Abrir conta cliente
            - Testa a criação de conta para cliente existente
            - Verifica: tipo de conta, saldo inicial e geração do número da conta.
            - Também criado testes em caso do cliente não existir
        - Consultar o saldo
            - Verifica se o saldo retornado é correto para uma conta existente.
            - Testa exceção se a conta não existe
        - Listar clientes
            - Verifica se o metodo retorna corretamente uma lista de clientes do repositório
            - Confirma a quantidade de clientes e dados corretos do DTO

8. Criação da classe ContaBancariaService e testes
    - Criado metodo para depositar
    - Metodo para sacar
    - Metodo para transaferir

    Testes e implementos
        - Criado teste para todos os metodos da classe ContaBancariaService
        - Depositar
        - Sacar
        - Transferir

    Seguindo as mesmas práticas e conceitos do testes criados para a class clienteService.

9. Criado a classe contaBancariaController para a criação dos endpoints: Depositar, Sacar e transferir.
    - Criado as classes OperacaoDTO e TransferenciaDTO, refatorado os metodos da classe contaBancariaService,
    para retorna as classe DTO, feito alguns testes no postman.

10. Criado a classe TransferênciaResponseDTO para saída de informações da classe TransferênciaDTO,
    - Refatorádo o metodo de transferência na classe de serviço e controle.
    - Refatorádo os testes unitários usando a classe TransferênciaResponseDTO e TransferênciaDTO.

11. Criado a a classe GlobalExceptionHandler para os erros e deixa-los mais elegantes
    - Metodo handlerValidationExceptions
    - handlerEntityNotFound
    - handleIllegalArgument
    - handlerGeneric
    Implementados teste unitarios para as exceções.

12. Criado classe de entidade Transacao, para mostrar dados de saída de cada operação, com atributos:
        tipoTransação classe Enum,
        valor,
        data e hora,
        contaDestino e contaOrigem
    Criado a classe dto ExtraDTO.
    Criado o repositorio, TransacaoRepository.
    Criado a classe de controle, TransacaoController, com o endpoint de extrato:
        consultarExtrato.
    Refatorado a classe de serviço, contaBancariaService, para retorna os extratos para cada operação.
    Criado o metodo para consultar o extrato na classe

 Resumo de todo o projeto até aqui.
    - Separação clara entre camadas (Controller, Service, Repository).
    - Uso de DTOs para proteger dados e validar entrada.
    - Geração automática de números de conta para evitar conflito.
    - Preparação para testes via Postman com exemplos de requisições e respostas.
    - Criado testes automatizados com JUnit e Mockito
    - Criado classes dto para o metodo de transferência.
    - Criado classe para extratos de cada operação da conta.